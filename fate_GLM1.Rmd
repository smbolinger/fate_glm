---
title: "Nest GLM"
author: "Sarah Bolinger"
date: '`r Sys.Date()`'
output:
  html_document:
    code_folding: hide
  pdf_document: default
editor_options:
  markdown:
    wrap: 72
---

## Introduction

What to do with this script:

1. Choose the data to load under section 1a
2. Decide how many categories you want to use for nest fate in section 1e
3. Check the models that will be fitted in section 3

I think it makes sense to keep the filtering function in the code for now? Easier to
edit it on the fly. Also, some of the dplyr stuff gets a little dicey in a custom package. 
Specifically, lines with across and last, like this:
              across(where(is.integer), last), # now they are all chr
              
              
Child documents referenced in the script: 

- fate_GLM_plots_tables.Rmd
- fate_GLM_diagnostics.Rmd

*NOTE* remember to change variable names in these documents, if needed!

Data is stored in "nest_models/cleaned_data" directory; 
  most recent data filename is stored in "import_name.txt" within that directory

fate_GLM_extra.Rmd has other related functions that I'm not currently using
fate_GLM_notes.txt has old notes from this script plus others about it and/or the data


## 0. SETUP

### a. Load packages; set rmarkdown options
If you try to knit a child doc twice, it fails bc of the "duplicate labels" bullshit.
but also, I don't need to run the missing/separation child twice

```{r setup, include=FALSE}
# remove(list=ls())
knitr::opts_chunk$set(echo = TRUE)
options(knitr.duplicate.label = "allow")
# knitr::knit_labels()

# library(AICcmodavg)
library(bbmle)
library(brglm2) # penalized logistic regression
# library(car)
library(gt)
library(gtsummary)
library(nestGLM)
library(stats)
library(tidyverse)
# library(visdat)   # visualize all data and number missing

# old_code.Rmd also has packages used in older versions of the script
```

### b. Set some values

```{r set-values, echo=FALSE}
homeDir <- "C:/Users/sarah/Dropbox/nest_models/"

predictors <- c("nest_age", "obs_int", "fdate") # numeric predictors to be used
prList     <- as.list(predictors)
prLabs <-  c("Nest Age (Days)", 
             "Final Interval (Days)",
             "Day of Season")
prNames <- c("NEST_AGE", "FINAL_INTERVAL", "END_DATE")
# names(predictors) <- prLabs
names(prList) <- prNames
now = format(Sys.time(), "_%m%d_%H%M_")

# filename <- paste0(homeDir,"glm_script/import_data_", now, ".csv")
# cat("import file name:", filename)
cat(">> homeDir =", homeDir, "     >> now =", now,"\n\n>> numeric predictor variables:\n\n")
# print(prList)
cat(paste(names(prList), prList, sep=": ", collapse="    "))

# change CI comma to a dash 
# from https://stackoverflow.com/questions/75637034/insert-dash-in-confidence-interval-instead-of-comma-in-r-gtsummary
my_theme <-
  list(
    "pkgwide-str:ci.sep" = " - "
  )

set_gtsummary_theme(my_theme)

```

### c. Create functions

#### Filter function


```{r filter-function, echo=TRUE}
filter_dat1 <- function(nestData, sites=c("RUTE","RUTW"), spp=c("LETE","CONI"),
                        # cam_nest=TRUE,
                        cam_vect=c("Y","y"),  debug=FALSE, grouped=FALSE){
  # cam_str <- c("Y","y")
  # if (all_cam) cam_str <- c("Y","y","Y*")
  if (debug) cat("camera strings:", cam_vect,"\n\n")
  ndGLM <- nestData %>%

    # mutate(fdate=final_obs_date) %>%    # this is also done later?
    mutate(
      fate = case_match(field_fate,
                                   "H"   ~ 1,
                                   "F"   ~ 0,
                                   "D"   ~ 2,
                                   "S"   ~ 3,
                                   "A"   ~ 4,
                                   "Hu"  ~ 5,
                                   "Ca"  ~ 6,
                                   "U"   ~ 7,
                                   "U?"  ~ 7,
                                   "U-H" ~ 8,
                                   "U-F" ~ 9
           ),

           cfate = case_match(cam_fate,
                                 "H"  ~ 1,
                                 "F"  ~ 0,
                                 "D"  ~ 2,
                                 "S"  ~ 3,
                                 "A"  ~ 4,
                                 "Hu" ~ 5,
                                 "Ca" ~ 6,
                                 "U"  ~ 7
           ),
           camera = ifelse(camera %in% cam_vect, TRUE, FALSE)

    ) %>%

    filter(site %in% sites) %>%
    # filter(species %in% c("CONI", "LETE")) %>%
    filter(species %in% spp) %>%
    filter(camera == TRUE)

  if(grouped==F){
    ndGLM <- ndGLM %>%
    group_by(nest)  %>%
    summarize(status = list(status),
              across(where(is.integer), last), # now they are all chr
              across(where(is.numeric), last),
              across(where(is.character), last) # summarize already goes rowwise
    ) %>%
    rowwise() %>%
    mutate_if(is.list, ~paste(unlist(.), collapse = '|'))

  }

  cat("Make sure you've selected the correct values:\n\n")
  # cat("\nSpecies:\n" )
  print(table(ndGLM$species))
  # cat("\nSite:\n")
  print(table(ndGLM$site))
  # cat("\nYear:\n")
  print(table(ndGLM$year))
  cat("\nHow many NAs are there in camera fate?\n", sum(is.na(ndGLM$cfate)), "\n")
  cat("\nAnd in nest age?\n", sum(is.na(ndGLM$nest_age)), "\n")

  return(ndGLM)
}
```





##*
------------------------------------------------------------------------

## 1. DATA

### a. Data settings: 

```{r other-settings, echo=FALSE}
debug        = FALSE

# missing_diag = FALSE
missing_diag = TRUE
separation   = FALSE

corrplots1   = FALSE
corrplots2   = TRUE

hist1        = FALSE
hist2        = TRUE

tab1         = FALSE
tab2         = TRUE

plsettings1 <- c(corrplots1,  
                   hist1,
                   tab1
                   )

plsettings2 <- c(corrplots2,  
                   hist2,
                   tab2
                   )

sites_sel <- c("RUTE", "RUTW")
spp_sel <- c("LETE", "CONI")
cam_str <- c("Y")

feb          = FALSE
addFieldFate = FALSE
grouped      = TRUE
compare      = FALSE
old_data     = FALSE

UHisH = TRUE
# UHisH = FALSE
# UFisF = TRUE
UFisF = FALSE

```


### b. Load cleaned data:

To run python code need reticulate package.

```{r load-data, echo=FALSE}

  filename <- paste0(homeDir,read_file(paste0(homeDir, "cleaned_data/import_name.txt")))
# if(debug) cat("importing from:",filename,"\n\n")
cat("importing from:",filename,"\n\n")
# nData <- read_csv(filename)[-1]
nData <- read_csv(filename)

```

### c. Filter the data:

```{r filter-data}
nData$fdate      <- nData$final_obs_date2
nData$final_fate <- nData$final_fate2
nData$field_fate <- nData$field_fate11
nData$obs_int    <- nData$final_obs_int3
nData$nest_age   <- nData$nest_age3 # nest age based on actual obs date and actual hatch date
nData$cam_fate   <- nData$cam_fate2

nd <- nData %>%
  filter(nest!=20365) %>%  # found on hatch day
  filter( nest!=20259) %>% # NA for final_obs_int (not tracked to fate)
  filter_dat1(cam_vect=cam_str, debug=debug,  # filters for cam by default
              grouped=grouped, spp=spp_sel, sites=sites_sel)
              # grouped=FALSE, spp=spp_sel, sites=sites_sel)

rm(nData)

```

How many NAs should there be in (camera) nest fate?

2021: 2
2020: 5
2019: 6

and nest age (of the remaining nests)?

2021: 13
2020: 1
2019: 2

```{r UHFisHF}

UHFnests <- unlist(nd %>% filter(fate == 8| fate == 9) %>% select(nest))

nd %>% filter(fate==8 | fate==9) %>% select(nest, field_fate, cam_fate, fate, cfate)

if(UHisH){
  nd$fate[nd$fate==8] = 1
}else{
  nd$fate[nd$fate==8] = 7
}

if(UFisF) nd$fate[nd$fate==9] = 0 else nd$fate[nd$fate==9] = 7

# nd %>% filter(nest %in% UHnests) %>% select(nest, field_fate, cam_fate, fate, cfate)
nd %>% filter(nest %in% UHFnests) %>% select(nest, field_fate, cam_fate, fate, cfate)
```

### d. Add the response vars:

```{r add-response, echo=TRUE}
ndGLM1 <- as.data.frame(add_vars(nd, debug=T))
ndGLM1 <- ndGLM1 %>% select(nest, species, field_fate, cam_fate, final_fate, estHD, k_adj, fdate, nest_age, obs_int, how_mis, HF_mis, misclass, is_u, hatchfail, c_hatchfail, fate, cfate)
# if(TRUE){
if(FALSE){
  ndGLM1 %>% select(nest, species, field_fate, cam_fate, fate, cfate, hatchfail, c_hatchfail, HF_mis, is_u) %>% write.csv(paste0("fates",now,".csv"))
}

print_vars(ndGLM1)

# saveRDS(nd, "nd.rds")
rm(nd)
```


```{r add-response, echo=TRUE}

```


------------------------------------------------------------------------
##*
------------------------------------------------------------------------

## 2. DIAGNOSTICS  

### a. Plots/frequency tables

```{r}
datName <- "ndGLM1"
prVars <- c("species", "cam_fate", "obs_int", "nest_age", "fdate")
if(sum(plsettings1 == 0)) cat(">> skip")
```


```{r plots_tables1, child=if(tab1 | hist1 | corrplots1) 'fate_GLM_diagnostics.Rmd'}
```

### b. Evaluate missing data, presence of separation

```{r}
if(missing_diag == FALSE & separation == FALSE) cat(">> skip")
```


```{r missing_sep2, child=if(missing_diag | separation) 'fate_GLM_diagnostics.Rmd'}
```



##*
------------------------------------------------------------------------

## 3. PREPARE DATA FOR MODEL

### a. Edit the data again to remove rows missing camera fate:

Remove the rows missing camera fate, which is a categorical var

Also, examine the missing values.

```{r remove-NA-fate}
ndGLM_miss1 <- dat_miss(ndGLM1) # moved this elsewhere because it is used there

ndGLM_red <- ndGLM1[!is.na(ndGLM1$cam_fate),]
table(ndGLM_red$field_fate)
cat("camera fate of nests marked unknown in the field:\n")
ndGLM_red %>% filter(field_fate=="U") %>% group_by(cam_fate) %>% summarize(sum = n())
cat("true cause of failure for failed (unknown) nests:\n")
ndGLM_red %>% filter(field_fate == "F") %>% group_by(cam_fate) %>% summarize(sum=n())
cat("marked failed (known cause) but reclassified:\n")
ndGLM_red %>% filter(field_fate %in% c("A", "D", "Hu", "S", "Ca") & misclass==1) %>% select(nest, species, field_fate, cam_fate) 
cat("marked hatched but reclassified as failed:\n") # only field fate was consolidated to 6 categories
ndGLM_red %>% filter(field_fate == "H" & HF_mis==1) %>% select(nest, species, field_fate, cam_fate)
cat("marked failed but reclassified as hatched:\n")
ndGLM_red %>% filter(field_fate %in% c("A", "D", "Hu", "S", "F", "Ca") & HF_mis==1) %>% select(nest, species, field_fate, cam_fate)
```


```{r remove-NA-fate}
ndGLM_red <- ndGLM_red[ndGLM_red$cam_fate!="U",]
ndGLM_red$nest[is.na(ndGLM_red$misclass)] 
ndGLM_red$misclass[is.na(ndGLM_red$misclass)] = 0 

ndGLM_miss <- dat_miss(ndGLM_red)

saveRDS(ndGLM1, file="ndGLM1.rds")
rm(ndGLM1)
```


### b. Edit and refactor the data:

This creaes the dataset to be used for the imputation

```{r set-types}

ndGLM_red <- ndGLM_red %>%
  set_var_types() %>%
  mutate(mclass = misclass == 1,
         isu    = is_u == 1) %>%
  mutate(across(c(isu, mclass), as.factor))

###### Change reference level of species: ##########################################
# ndGLM_red$species <- relevel(ndGLM_red$species, ref="LETE")

print_vars(ndGLM_red)

nfate=6
ndGLM_ <- ndGLM_red %>%
  refactor(num_fate=nfate) 
levels(ndGLM_$cam_fate)
  
ndGLM_ %>% sapply(function(x) sum(is.na(x)))
var <- "nest_age"
stillMissing <- ndGLM_$nest[which(is.na(ndGLM_[[var]]))]

# save the intermediate objects to .rds so you can remove them to save memory?

saveRDS(ndGLM_red, "ndGLM_red.rds")
rm(ndGLM_red)



### 4 FATES: ##########################
# ndGLM4 <- ndGLM_red %>%
#   refactor(num_fate=4) 

### 3 FATES: ##########################
# ndGLM3 <- ndGLM_red %>%
#   refactor(num_fate=3) 
```

##*
------------------------------------------------------------------------

## 4. VISUALIZE DATA AFTER REMOVING NAs AND EDITING

### a. Specify the name of the data being used so the file outputs are named accordingly.

```{r names-2}
datName <- "ndGLM_"
prVars <- c("species", "cam_fate", "obs_int", "nest_age", "fdate")
if(sum(plsettings2 == 0)) cat(">> skip")
```

For some reason, taking out the line break in the middle of these chunks is upposed to fix the duplicate label error:

```{r plots_tables2, child=if(tab2 | hist2 | corrplots2) 'fate_GLM_plots_tables.Rmd'}
```




##*
------------------------------------------------------------------------

## 5. RUN THE MODELS
### a. Create the complete cases dataframe

```{r rem-NA, include=FALSE}
ndGLM_cc <- ndGLM_  %>%
  select(
    nest, is_u, HF_mis, misclass, species, cam_fate, nest_age,
    fdate, obs_int
) %>% # I don't know why this isn't working
  remove_na(allNA = ndGLM_miss)

print_vars(ndGLM_cc)

saveRDS(ndGLM_cc, "ndGLM_cc.rds")
rm(ndGLM_cc)
# ndGLM_unscl_cc %>% sapply(function(x) sum(is.na(x)))
```

### b. Create scaled dataframe:

```{r scale-df, echo=TRUE}
# ndGLM_scl <- ndGLM1 %>%
ndGLM_scl <- ndGLM_ %>%
  mutate(across(predictors, function(x) as.numeric(scale(x,scale=F)))) #%>%
ndGLM_scl_cc <- ndGLM_scl %>% remove_na(allNA = ndGLM_miss)

saveRDS(ndGLM_, "ndGLM_.rds")
rm(ndGLM_)
```

### c. Define the models that will be compared:

```{r formulas, eval=FALSE, include=FALSE}
# These aren't ONLY the models I initially had hypotheses about, BUT we are also 
# not fishing through every possible model. 
cat("exclude model # 3")
# resp="is_u"
modList <- c()
# rewrite 

modList <- c(
  "~ species + nest_age + fdate + cam_fate + obs_int",
  "~ 1",
  "~ species + nest_age + fdate + obs_int",
  # "~ species + cam_fate * nest_age + fdate + obs_int",
  # "~ species * cam_fate + nest_age + fdate + obs_int",
  "~ species * obs_int + cam_fate + nest_age + fdate ",
  # "~ species + cam_fate + fdate + obs_int * nest_age ",
  # "~ species + nest_age + fdate + obs_int * cam_fate",
  "~ nest_age * species + fdate + obs_int + cam_fate",
  # "~ species * nest_age + fdate + obs_int + cam_fate",
  # "~ species + cam_fate + nest_age + obs_int * fdate"
  # "~ species * fdate + cam_fate + nest_age + obs_int"
  # "~ species + nest_age + cam_fate + obs_int",
  "~ species * nest_age + cam_fate + obs_int",
  # "~ species + cam_fate * nest_age + obs_int",
  "~ species * obs_int + cam_fate + nest_age ",
  "~ species * obs_int + fdate + nest_age ",
  "~ species *  nest_age + fdate + obs_int",
  # "~ species + cam_fate + obs_int * nest_age ",
  # "~ species + nest_age + obs_int * cam_fate",
  "~ species + nest_age + cam_fate + fdate",
  "~ nest_age + cam_fate + fdate + obs_int",
  "~ nest_age + cam_fate + fdate",
  # "~ species + nest_age + cam_fate",
  # "~ species * nest_age + cam_fate",
  "~ species * nest_age + obs_int",
  "~ species * obs_int + nest_age"
  # "~ species + nest_age * cam_fate",
  # "~ species + nest_age ",
  # "~ species * nest_age ",
  # "~ nest_age "
)
```


```{r formulas, echo=FALSE}
prOrder <- c("species", "nest_age", "obs_int", "fdate", "cam_fate")
inter <- c("species * nest_age")
inter
inter2 <- c("species * obs_int") # has to be a vector to work with expand_grid
otherVar <- c("cam_fate", "fdate", "obs_int")
otherVar
list(otherVar)
otherVar2 <- c("cam_fate", "fdate", "nest_age")

# inter1 <- c("species", "nest_age", "species:nest_age")
combMod <- function(inter, otherVar){
  # combos <- c(otherVar, combn(otherVar, 2), unlist(otherVar)) # c combines all the elements of each into one big vector
  # where are the names coming from??
  combos <- append( append( list( otherVar), asplit(combn(otherVar, 2), MARGIN=2)), as.list(otherVar) )
  cc <- lapply(combos, 
               function(x) paste( inter,
                                  paste(x, collapse=" + "), 
                                  sep=" + ")
  )
  return(cc)
}

mEffects <- paste(prOrder, collapse=" + ")
andesEtAl <- paste(prOrder[-5], collapse=" + ")
modList <- c(combMod(inter, otherVar), combMod(inter2, otherVar2), "1", mEffects, andesEtAl)
modList <- paste("~", modList, sep=" ")
modList
  # combos <- append( list( otherVar), asplit(combn(otherVar, 2), MARGIN=2), as.list(otherVar) )
  # combos <- list( list(otherVar), asplit(combn(otherVar,2), MARGIN=2), as.list(otherVar))
  # modList <- paste(inter, unname(combos), sep="+", collapse="+")
  # modList <- lapply(combos, function(x) paste(inter, combos, collapse="+"))
  # modList
  # modList <- append(expand.grid(inter, unlist(combos)), inter)
  # modList <- lapply(asplit(expand.grid(inter, combos), MARGIN=1), function(x) paste(unlist(x, recursive=FALSE), sep="", collape="+"))
  # modList1 <- paste(modList, sep="+")
  # combos <- list()
  # for( n in seq_along(otherVar) ){
    # combos[[n]] <- combn(otherVar, 2)
  # }
# # }
# 
# 
# # n <- unlist(combn(otherVar1, m=2), otherVar1, unlist(otherVar1))
# # expand.grid(inter, unlist(combos))
# # for n in seq_along(otherVar){
# #   ll[[n]] <- 
# # }
# ee <- expand.grid(inter, combos)
# ees <- asplit(ee, MARGIN=1)
# eesl <- lapply(ees, function(x) unlist(x, recursive=FALSE))
# eeslp <- paste(eesl, sep="", collapse="+")
# # unlist(expand.grid(inter,combos))
# modEq1 <- expand.grid(inter1, otherVar1)# not quite what I need
# modEq2 <- expand.grid(inter2, otherVar2)
# # glmFit <- glm(formula="isu ~ species * nest_age + fdate + obs_int + cam_fate", 
# #               family = binomial(), 
# #               data = ndGLM_unscl_cc)
```

### d. Define the data and vars that will be used:
Put the name of the dataframe so it can be used in the file naming.
Also lets you choose the response variable for question 2 (HF_mis or misclass) and the method to use for the logistic regression

```{r mod-data}

# datName      <- "ndGLM_cc"
datName      <- "ndGLM_scl_cc"
# datNameImp   <- "ndGLM_"
datNameImp   <- "ndGLM_scl"
# resp2   <- "misclass"
# met     <- "glm.fit"
# met     <- "jeffreys"
met     <- "brglm2"
impMet  <- met
fVar <- "_allFates"
uVar <- "_UHisU"
if(UHisH) uVar <- "_UHisH" 
if(exists("nfate")) fVar <- paste0("_",nfate,"fates") # exists seems to be more complicated than I thought...
```


------------------------------------------------------------------------
##*
------------------------------------------------------------------------

## QUESTION 1: What affects whether nest fate is classifiable from field evidence?

AKA is there field evidence or not


### Analysis (complete cases)

*NOTE* Make sure there are no warnings - separation etc.

#### Run the normal analysis:

```{r q1, warning=FALSE}
question <- "Was nest fate classifiable in the field?"
quest   <- "_q1"
# dat <- parse(datName) # this one appears to be for files
dat <- get(datName)
mods <- list()
resp   <- "is_u"
modList2 <- paste(resp, modList, sep=" ")
# modList3 <- lapply(modList2, function(x) as.formula(x)) # what is benefit of formula type?

cat(question)
cat("\n\nData used:", datName)
cat("\n\nNumber of fate categories:", length(levels(dat$cam_fate)))
cat("\n\nRESPONSE VAR:",resp, "\n\n")
cat("\n\nModels to fit:\n",paste(modList2, collapse="\n" ))

# mods <- run_models(dataMod=dat, resp="is_u", modlist=modList)
# cat("\n\nclassifiable / not classifiable in field")
# table(ndGLM_unscl_cc$is_u)

# mods <- run_models(dataMod=dat, resp="is_u", modlist=modList, met="brglm2", iter=500000)
# mods <- run_models(dataMod=dat, resp="is_u", modlist=modList, met="jeffreys")
# mods <- run_models(dataMod=dat, resp=resp1, met="glm.fit", modlist=modList)
mods <- run_models(dataMod=dat, resp=resp, met=met, modlist=modList)
# write.csv(ndGLM_cc, "nestdata2_.csv")
# sjPlot::plot_model(mods[[5]], type="int")
```
### CREATE AIC TABLES AND REGRESSION TABLES:

```{r q1_aic, child="fate_GLM_AICc.Rmd"}
```


### USING THE IMPUTED DATASETS:

The imputed datasets are stored in one object of class "mids"

The default for the mice package is to run all of the imputed datasets
(20, in this case) through your model and pool the results

-   Since I have many models, I looped through them and applied this
    default approach first

```{r q1-impute, child="fate_GLM_imputation.Rmd"}
```






##*
------------------------------------------------------------------------

## QUESTION 2: How do the predictor vars affect classification accuracy?

Response: HF_mis were nests correctly marked hatched/failed, or not

*NOTE* MAYBE should be recast as "was nest hatch misclassified?" so that unknowns that were actually hatched count as misclassified but unknowns that were actually failed don't?

```{r}
# # remove nests that were marked unknown in the field:
# ndGLM_scl_red <- ndGLM_scl %>% filter(fate != 7)
# ndGLM_scl_redcc <- ndGLM_scl_cc %>% filter(fate != 7)
# 
# datName <- "ndGLM_scl_red"
# prVars <- c("species", "cam_fate", "obs_int", "nest_age", "fdate")

```

IF using the reduced data for question 2, print plots/tables again

### Analysis (complete cases )

#### Specify & run the analysis

```{r q2, echo=TRUE}
question <- "Was nest fate classified correctly in the field?"
quest    <- "_q2"
# datName <- "ndGLM_scl_redcc"
cat(question)
dat <- get(datName)
mods <- list()
resp   <- "HF_mis"
# cat("\n\nNumber of fate categories:", length(levels(ndGLM_2_cc$cam_fate)))
cat("\n\nData used:", datName)
cat("\n\nNumber of fate categories:", length(levels(dat$cam_fate)))
# mods <- run_models(dataMod=datList[[i]], resp="is_u", modlist=modList)
cat("\n\nRESPONSE VAR:",resp,"\n\nMODELS:\n")
# mods <- run_models(dataMod=dat, resp=resp, met="logistf", modlist=modList)
# mods <- run_models(dataMod=dat, resp=resp, met="jeffreys", modlist=modList)
# mods <- run_models(dataMod=dat, resp=resp2, met="glm.fit", modlist=modList)
mods <- run_models(dataMod=dat, resp=resp, met=met, modlist=modList)
# mods <- run_models(dataMod=dat, resp=resp, met="brglm2", modlist=modList)
# intPlot <- 
sjPlot::set_theme(
  base=theme_classic()
  
)
sjPlot::plot_model(mods[[5]], type="int") +
  labs(x="Nest age (days)", y="Predicted probability \nof misclassification", title="Interaction Plot for Species and Nest Age")

# j+
  # theme_classic()


#+
 # scale_fill_manual(values = species,
  #                  labels=c("Common\nNighthawk",
   #                          "Least\nTern"))
# intPlot
```


```{r echo=TRUE}
```

### CREATE AIC TABLES AND REGRESSION TABLES:

```{r q2_aic, child="fate_GLM_AICc.Rmd"}
```


### USING THE IMPUTED DATASETS:
```{r}
# datName <- "ndGLM_scl_red"
```


```{r q2-impute, child="fate_GLM_imputation.Rmd"}

```

------------------------------------------------------------------------
### end
------------------------------------------------------------------------