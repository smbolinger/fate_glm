---
title: "Untitled"
author: "Sarah Bolinger"
date: "`r Sys.Date()`"
output: html_document
---


## Run all of these once:

### Functions

```{r, warning=FALSE}
###  to perform the multiple imputations ###############################################

# impRes <- impDat %>%
#   select(nest, nest_age, obs_int, cam_fate, fdate, species, HF_mis, misclass, is_u) %>%
#   # runImpMods(.,modList=modList,resp="is_u")
#   runImpMods(.,modList=modList,regMethod = impMet,resp=resp, pool=FALSE, impute=FALSE)
# summary(impRes)
# impRes

# all of this is what is inside the function
# impDat1 is the result of get(datNameImp)

imputeDat <- function(impDat1, m = 10, return = "complete"){
  
  # impDat1 <- get(datNameImp)
  impDat  <- mice::mice(impDat1, seed=613, m=m, printFlag=FALSE)
  impDat2 <- mice::complete(impDat, "all") # generate a list of all the completed datasets
  
  print(plot(impDat))
  print(attributes(impDat))
  
  if(return=="complete") return(impDat2) else return(impDat)
}

# fit the models using each of the m datasets
impFit <- function(impDat, modList){
  
    impMod <- vector(mode="list", length=length(modList))
    
    for (m in seq_along(modList)){
      impMod[[m]] = with(impDat, glm(as.formula(
        # paste0(resp, modList[[m]])), family=fam, method=brglm2::brglm_fit))
        
        # how come regMet works in the nestGLM package but not here??
        paste0(resp, modList[[m]])), family=fam, method = regMet, 
        # paste0(resp, modList[[m]])), family=fam, method =impMet,
        control=brglmControl(maxit=iter)
      ))
    }
    
    return(impMod)
    
}

# pool the results
poolImp <- function(impMod, modList){
  impModPool <- vector(mode="list", length=length(modList))
  
  for(m in seq_along(modList)){
    impModPool[[m]] = mice::pool(impMod[[m]])
    summary(impModPool[[m]])
    # impModPool[[m]] %>%
    #   gt::gt() # was this new? not working 12 aug 25
  }
  return(impModPool)
}
# dat <- impDat
# modnum=top_num
# plot_type = "pred"
# # if(grepl("*", modList[top_num], fixed=TRUE)){
# vars = c(intVar1, intVar2)
# y_lab="e"
# x_lab="jjkjk"
# grid1 <- intGridObs

# create the interaction plots
grpColor <- c(LETE="#AA4499", CONI="#44AA99")
intPlot <- function(dat, 
                    modnum, 
                    plot_type = "pred", 
                    vars=c("species", "nest_age"),
                    y_lab = "Predicted probability of\n misclassification",
                    x_lab = "Nest age - centered (days)",
                    # grid=intGrid1 # probably shouldn't have the same name as a function?
                    # grid1=intGrid1 # probably shouldn't have the same name as a function?
                    grid1
                    ){
  
    model   <- with(dat,
                    glm(as.formula(paste0(resp, modList[[modnum]])),
                    family=binomial,
                    method=regMet
                    ))
    
    #  from the documentation: 
    #  Warning: Slopes and elasticities can only be calculated for continuous numeric variables. The slopes() functions will automatically revert to comparisons() for binary or categorical variables.
    #  
    #  Why are all the predictions only a few values?
    # intPred <- marginaleffects::predictions(model,
    #                                         # variables=c("species", "nest_age"),
    #                                         variables=c("species"), # try just including X
    #                                         newdata=grid1
    #                                         # so was this always working with these 2 variables?
    #                                         # I guess it was ignoring it when it was "nest_age"
    #                                         # except when the grid also varied nest_age, 
    #                                         # which is why the species*nest_age interaction plot
    #                                         # wasn't working
    #                                         # but anyway, I don't think I need the variables arg?
    #                                         # nope, still not working for the species*nest_age interaction
    #                                         # and the CI are much narrower now for the ones that work
    #                                         # could be because I changed the interaction order?
    #                                         # why does nest_age*species work, but not the reverse?
    #                                         # and why is the other one obs_int*species, not the reverse?
    #                                         # changing the order without putting the variables
    #                                         # argument back in didn't help anything...
    #                                         # variables=vars
    #                                         )
    
    # this one gives a list as output:
    # plDat   <- ifelse(plot_type=="slope",as.data.frame(intSlope),as.data.frame(intPred))
    # plDat <- intPred
    # if(plot_type=="slope") plDat <- intSlope
    # the confidence intervals in this plot don't seem wide enough...
    # plDat <- case_when(plot_type == "pred" ~ intPred,
    #                    plot_type == "slope" ~ intSlope)
    # ggplot(intPred,
    mm <- sym(vars[1])
    xx <- sym(vars[2])
    # colores <- c("")
    # g <- ggplot(plDat,
    
    # I didn't change anything about the ggplot function call
    # or really anything about this function definition, except for making it so that
    # the variables used for predictions aren't always species & nest age 
     if(plot_type=="slope"){
      
      intSlope <- marginaleffects::slopes(model,
                                          variables=c("species"),
                                          # variables=vars,
                        # variables=c("species", "obs_int"),
                        newdata=grid1)
      pl <- ggplot(intSlope,
             aes(x=!!xx, y=estimate, ymin=conf.low, ymax=conf.high,color=!!mm)) +
        labs(x=x_lab, y=y_lab)+
        scale_color_manual(values=grpColor,
                           labels=c("Common\nNighthawk", "Least Tern"),
                           name="Species") +
        geom_ribbon(alpha=0.2) +
        geom_line() +
        theme_classic() +
        theme(axis.text = element_text(size=18),
        axis.title = element_text(size=20), # can't do margins for x and y axis titles at once
        legend.text=element_text(size=16),
        legend.title=element_text(size=18),
        axis.title.y = element_text(margin=margin(r=5)),
        axis.title.x = element_text(margin=margin(t=5))) 
        
    } else {  # ggplot(plDat,
      intPred <- marginaleffects::predictions(model,
                                              # variables=c("species", "nest_age"),
                                              variables=c("species"), # try just including X
                                              newdata=grid1
      )  
      pl <- ggplot(intPred,
             # aes(x=obs_int, y=estimate, ymin=conf.low, ymax=conf.high, color=species)) +
             # aes(x=as.numeric(obs_int), y=estimate, ymin=conf.low, ymax=conf.high, color=species)) +
             aes(x=!!xx, y=estimate, color=!!mm)) +
        # geom_point() +
        labs(x=x_lab, y=y_lab)+
        scale_color_manual(values=grpColor,
                           labels=c("Common\nNighthawk", "Least Tern"),
                           name="Species") +
        geom_smooth(method=NULL) +
        theme_classic() +
        theme(axis.text = element_text(size=18),
        axis.title = element_text(size=20), # can't do margins for x and y axis titles at once
        legend.text=element_text(size=16),
        legend.title=element_text(size=18),
        axis.title.y = element_text(margin=margin(r=5)),
        axis.title.x = element_text(margin=margin(t=5))) 
        # geom_ribbon(alpha=0.2) +
        # geom_line()
      
    }
    
    return(pl)
  }
# }
```

### Function to create the pooled regression table for the top model:

```{r, warning=FALSE}
# top_num <- aicTabImp$num[1]
# regtab <- function(aicTabImp, modList, howManyMod){
regtab <- function(aicTabImp, modList){
  # browser()
  # top_num <- as.numeric(rownames(aicTabImp)[1])
  # # sec_top <- aicTabImp$num[2]
  # sec_top <- as.numeric(rownames(aicTabImp)[2])
  # th_top  <- as.numeric(rownames(aicTabImp)[3])
  # 
  # cat("top model:", modList[top_num])
  # intVar1 <- str_extract(string = modList[top_num], pattern = "\\w+(?=\\s\\*)")
  # intVar2 <- str_extract(string = modList[top_num], pattern = "(?<=\\*\\s)\\w+")
  # cat("\ninteraction variables:", intVar1, intVar2)
  # 
  # cat("\n\nsecond best model:", modList[sec_top])
  # intVar1.2 <- str_extract(string = modList[sec_top], pattern = "\\w+(?=\\s\\*)")
  # intVar2.2 <- str_extract(string = modList[sec_top], pattern = "(?<=\\*\\s)\\w+")
  # cat("\ninteraction variables:", intVar1.2, intVar2.2)
  # cat("\ndelta AIC of second best model:", aicTabImp$deltaAIC[2])
  
  # cat("\n\ncreating regression table for top model, model number", top_num, "; \nmodel formula:", paste(modList[top_num]))
  
    modnum  <- as.numeric(rownames(aicTabImp)[m])
    # NOTE - will change based on whether there is a space in the modname
    intVar1 <- str_extract(string = modList[modnum], pattern = "\\w+(?=\\s\\*)")
    intVar2 <- str_extract(string = modList[modnum], pattern = "(?<=\\*\\s)\\w+")
    cat("\nmodel number", modnum,"=", modList[modnum], ", with these interaction vars:", intVar1, intVar2, ", and delta AIC:", aicTabImp$deltaAIC[m], "\n")
    fit <- with(impDat, glm(as.formula(paste(resp, modList[[modnum]])), family=binomial, method=brglm2::brglmFit)) 
    # pass results to tbl_regression before pooling, and it will handle pooling + tidying:
    vars=c('species', 'nest_age', 'obs_int', 'cam_fate', 'fdate')
    varNames=c('SPECIES', 'NEST_AGE', 'FINAL_INTERVAL', 'TRUE_FATE', 'END_DATE')
    vnames = as.list(varNames)    
    names(vnames) <- vars
    # tabOR <- gtsummary::tbl_regression(pool.fit, label=vnames, exponentiate=TRUE)
    summ.fit <- gtsummary::tbl_regression(fit, label=vnames, exponentiate=TRUE)
    summ.fit
    # fn <- sprintf("_q1_reg_imp_%s_%s.rtf", datNameImp, now)
    headr <- paste("Pooled MI Regression Summary for Model:",
                   modnames(list(x = mods[[modnum]]), null=FALSE),
                   sep="\n")
    fn <- sprintf("%s_regtab_imp_%s-%s_%s.rtf", quest, datNameImp,modnum, now)
    summ.fit %>%
      gtsummary::as_gt() %>%
      gt::tab_header(title=headr) %>%
      gt::gtsave( filename=fn, path="analysis/" )
    # return(summ.fit)
    print(summ.fit)
    return(fit)
  }
  # impTab <- impModTab(impModPool = impRes,modList = modList)
```

Functions to create interaction plots:

```{r}

# create_grid <- function(dat, var){
intPredict <- function(model, var){

  # nm <- paste("intGrid_", var)
  # grid
  # assign(x = nm, value=marginaleffects::datagrid(newdata=ndGLM_scl, grid_type="balanced"))
  # return(nm)
  # model   <- with(dat,
  #                 glm(as.formula(paste0(resp, modList[[modnum]])),
  #                 family=binomial,
  #                 method=regMet
  #                 ))
  # intPred <- 
  # grid1 <- marginaleffects::datagrid(newdata=ndGLM_scl, grid_type="balanced")
  # grid1 <- get(nm)
  intPred <- marginaleffects::predictions(model, newdata=grid1)
}


```

### Create a small set of imputations (m=10) for testing code (does not run during knitting)

Also tells R to use the smaller set for the other functions

```{r eval=FALSE, include=FALSE, warning=FALSE}
# impute, without completing the datasets so you can use the fit command?
impDat_small <- imputeDat( impDat1 = imppDat, return= "") # default m value is 10
smallFit <- impFit(impDat_small, modList)
smallPool <- poolImp(smallFit, modList)
# Error in `brglm2::brglm_fit`(x = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  : 
#  could not find function "brglm2::brglm_fit"
#       MAYBE HELPFUL:
# pkg::name returns the value of the exported variable name in namespace pkg, whereas pkg:::name returns the value of the internal variable name. 

# impDatsmall  <- mice::mice(impDat1, seed=613, m=10, printFlag=FALSE)
# impDatsmall2 <- mice::complete(impDatsmall, "all") # generate a list of all the completed datasets
impDat <- impDat_small
impMod <- smallFit
impModPool <- smallPool
```

### Create imputed datasets (m=100)

#### How many imputations?

```{r eval=FALSE, warning=FALSE, include=FALSE}
modList
impDatTest <- mice::mice(imppDat, m=20, method='pmm', printFlag=FALSE)
# fitTest    <- with(impDatTest, glm())
fitTest <- impFit(impDatTest, modList = modList)

howManyImp <- lapply(fitTest, function(x) howManyImputations::how_many_imputations(x, cv=0.05))
```

#### Really only need to create the imputed data 

To deal with interactions (which should be included in the imputation model), use 
transform-then-impute (von Hippel 2009) - BUT this method may require MCAR?

Explicitly compute the interaction term by creating a variable that equals:
  dummy species variable(1=LETE, 0=CONI) times the other variable in the interaction

Then drop species from the dataset

FOr this to work, need to rewrite the models in terms of the new interaction variable.

```{r, warning=FALSE}

# change CI comma to a dash - now this is in the main script at the beginning
# from https://stackoverflow.com/questions/75637034/insert-dash-in-confidence-interval-instead-of-comma-in-r-gtsummary
# my_theme <-
#   list(
#     "pkgwide-str:ci.sep" = " - "
#   )
# 
# set_gtsummary_theme(my_theme)

get(datNameImp) %>% select(species, cam_fate, fdate, obs_int, nest_age) %>% mice::md.pattern()

# interaction with obs_int
imppDat1 <- get(datNameImp) %>% 
  mutate(species = as.numeric(species=="LETE"),
         sp_obsInt = species * obs_int) %>% 
  # select(species, cam_fate, fdate, nest_age, obs_int) 
  select(species, obs_int, cam_fate, fdate, nest_age, sp_obsInt) 

imppDat2 <- get(datNameImp) %>% 
  mutate(species = as.numeric(species=="LETE"),
         sp_age = species * nest_age) %>% 
  # select(species, cam_fate, fdate, nest_age, obs_int) 
  select(species, obs_int, cam_fate, fdate, nest_age, sp_age) 
# impDat       <- imputeDat(impDat1 = imppDat, m=100, return="")
# impDat2 <- impDat
# impDat  <- mice::mice(imppDat, seed=613, m=100, printFlag=FALSE)
# impDat  <- mice::mice(imppDat, seed=613, m=30, printFlag=FALSE)
impDat1  <- mice::mice(imppDat1, seed=613, m=30, printFlag=FALSE)
impDat2  <- mice::mice(imppDat2, seed=613, m=30, printFlag=FALSE)

impDat1$predictorMatrix
impDat2$predictorMatrix
# May actually only require 25 imputations, but that will change all the numbers slightly (AIC
# rankings stay the same)
# impDat  <- mice::mice(imppDat, seed=613, m=25, printFlag=FALSE)
```

### Stratification

Another method for dealing with interactions - impute-then-transform

Impute separately for each species (each level of categorical var) and then combine

```{r}
col_sel <- c(prVars, resp) # columns to select, as strings
datLT <- get(datNameImp) %>% filter(species=="LETE") %>% select(all_of(col_sel))
impLT <- mice::mice(datLT, seed=613, m=30, printFlag=FALSE)

datCO <- get(datNameImp) %>% filter(species=="CONI") %>% select(all_of(col_sel))
impCO <- mice::mice(datCO, seed=613, m=30, printFlag=FALSE)

impInt <- rbind(impLT, impCO)
```

## .
#########################################################################################
#########################################################################################
## Run all of these for each separate analysis:

### Settings

```{r}
# (see chunk further down)
regMet <- "brglm_fit"
# regMet <- "glm.fit"
# regMet  <- "brglm2:::brglm_fit"
# regMet  <- "brglm2::brglmFit"
fam     <- binomial
iter    <- 500
fVar <- "_allFates"
uVar <- "_UHisU"
if(UHisH) uVar <- "_UHisH" 
if(exists("nfate")) fVar <- paste0("_",nfate,"fates") # exists seems to be more complicated than I thought...
cat("* * * * * * * * * * * * * * * * * * * * * * * * * * * *")
cat("\n* imputation using this data:", datNameImp)
cat("\n* and this response variable:", resp)
# cat("\nand this method:", impMet)
cat("\n* and this method:", regMet)
cat("\n* * * * * * * * * * * * * * * * * * * * * * * * * * * *")
```

### Fit & pool the results

Depends on response variable - must run each time you change it

```{r, warning=FALSE}
# uses the response specified in fate_GLM1.Rmd
impMod       <- impFit(impDat = impDat, modList = modList)
impModPool   <- poolImp(impMod = impMod, modList= modList)
```

### Create the AIC table with the model fit using the imputed data

Extract the degrees of freedom, as well as the average AIC, Akaike weight, & log likelihood 
(across all imputations) for each model, and create the AIC table.

```{r}
# lapply(impRes, summary)
fname <- paste0(datNameImp,"_impAIC",quest,uVar,fVar)

# need to have fit the models in the main script for this to work (just for naming):
aicImp <- aicImpMods(impModPool = impModPool,modList = modList,mods=mods,filePrefix = fname)
# only output is the filename - can't see the R object
# now the function also saves an RDS of the imputation AIC info.
aicImpDat <- readRDS("aicImpMod.rds")
# aic <- as.data.frame(aicImpDat)
# aic <- purrr::map_df(aicImpDat, tibble::as_tibble) # deprecated function
aicTabImp <- readRDS("impAICtab.rds")
aicTabImp
knitr::include_graphics(paste0("analysis/",aicImp),
# knitr::include_graphics(aicImp, 
                        dpi=(1300/6)) # dpi setting = only thing that works
```



```{r eval=FALSE, warning=FALSE, include=FALSE}
# this works:

# fit <- with(impDat, glm(as.formula(paste(resp1, modList[[5]])), family=binomial, method=brglm2::brglmFit)) 
# use the number of the top model to evaluate it:
# fit <- with(impDat, glm(as.formula(paste(resp, modList[[top_num]])), family=binomial, method=brglm2::brglmFit)) 
# # pass results to tbl_regression before pooling, and it will handle pooling + tidying:
# vars=c('species', 'nest_age', 'obs_int', 'cam_fate', 'fdate')
# varNames=c('SPECIES', 'NEST_AGE', 'FINAL_INTERVAL', 'TRUE_FATE', 'END_DATE')
# vnames = as.list(varNames)    
# names(vnames) <- vars
# # tabOR <- gtsummary::tbl_regression(pool.fit, label=vnames, exponentiate=TRUE)
# summ.fit <- gtsummary::tbl_regression(fit, label=vnames, exponentiate=TRUE)
# summ.fit
# # fn <- sprintf("_q1_reg_imp_%s_%s.rtf", datNameImp, now)
# fn <- sprintf("_%s_reg_imp_%s_%s.rtf", quest, datNameImp, now)
# summ.fit %>%
#   gtsummary::as_gt() %>%
#   gt::gtsave( filename=fn, path="analysis/" )


```

### Create the regression table(s) for the top model(s):

```{r, warning=FALSE}
howManyMod = 3
for(m in 1:howManyMod){
  tab <- regtab(aicTabImp, modList)
  
}
```

### Plot the marginal effects if there is an interaction in the top model:

For other methods I tried that didn't work, see old_code document

Or use stratification as seen here: https://www.bookdown.org/rwnahhas/RMPH/mi-mlr.html

marginaleffects package: 

- use avg_comparisons for categorical variables and get the average predicted values for each level of X; and by=M to see if the changes depend on a moderator M

When M is continuous, use the predictions() function because calculating an average for each value of a continuous variable is not practical.

#### Create the datagrid objects that marginal effects will use as "newdata" when making predictions

```{r}
# if(grepl("*", modList[top_num], fixed=TRUE)){
# var <- "obs_int"
# # intGridNew1 <- marginaleffects::datagrid(newdata=ndGLM_scl,
```


```{r}
intGridAge <- marginaleffects::datagrid(newdata=ndGLM_scl,
                                         # species=c("CONI", "LETE"),
                                         # nest_age= c(-15:15)) # using the centered data
                                        
                                        # try using only M in the grid
                                        # do I need length.out to be longer bc the df is high?
                                         # nest_age= seq(-15, 15, length.out=100)) # using the centered data
                                         nest_age= seq(-15, 15, length.out=200)) # using the centered data
                                     # obs_int = c(-4:6))
fullGridAge <- marginaleffects::datagrid(newdata=ndGLM_scl,
                                         species=c("CONI", "LETE"),
                                         nest_age= seq(-15, 15, length.out=200)) # using the centered data
                                         # nest_age= fivenum) # using the centered data

intGridObs  <- marginaleffects::datagrid(newdata=ndGLM_scl,
                                          # species=c("CONI", "LETE"),
                                         # obs_int = c(-4:6)) # not a lot of values - hard to 
                                                            # get a smooth curve
                                         # using 1000 values doesn't seem to help with slopes plot
                                         # and it makes intPred have 20,000 observations
                                         # obs_int = seq(from=-4, to=6, length.out=1000)) 
                                          obs_int = seq(from=-4, to=6, length.out=200)) 
                                           
fullGridObs  <- marginaleffects::datagrid(newdata=ndGLM_scl,
                                          species=c("CONI", "LETE"),
                                          obs_int = seq(from=-4, to=6, length.out=200))
                                          # obs_int = fivenum) 
# }
if(resp=="is_u"){
  yl = "Predicted probability of\nunknown field fate"
} else {
  yl = "Predicted probability of \nmisclassification"
}
# intGridNew3 <- marginaleffects::datagrid(newdata=ndGLM_scl,
#                                          species=c("CONI", "LETE"),
#                                          )

```
```{r}
# makeIntGrid <- function(xvar, mvar, newD){
#   
# }
```

#### Go ahead and plot the interactions in all models that are in the top model set:

```{r, warning=FALSE}
if(grepl("*", modList[top_num], fixed=TRUE)){ # the defaults are for this model
  # change the grid used based on which variables are in the interaction:
  if(intVar2 == "obs_int"){
    # gr = intGridObs 
    grName = "intGridObs"
    lab = "Final interval - centered (days)"
  } else {
    # gr = intGridAge
    grName = "intGridAge"
    lab = "Nest age - centered (days)"
  }

  intPlot(impDat,                             # (interaction between species & nest_age)
          # modnum=5)
          modnum=top_num,
          vars = c(intVar1, intVar2), # in this case, intVar1 should always be species
          # grid1=gr,
          grid1=get(grName),
          x_lab=lab,
          y_lab=yl)
  # ,
          # y_lab="Predicted probability of\n unknown field fate")                   
}
# g <- get(grName)
# rm(g)
```


```{r, warning=FALSE}
if(grepl("*", modList[sec_top], fixed=TRUE)){
  # if("obs_int" %in% c(intVar1.2, intVar2.2)){
  if(intVar2.2 == "obs_int"){
    # gr = intGridObs
    grName = "intGridObs"
    lab = "Final interval - centered (days)"
  } else {
    # gr = intGridAge
    grName = "intGridAge"
    lab = "Nest age - centered (days)"
  }
  
  intPlot(impDat,
            # modnum=4, 
            modnum=sec_top, 
            # grid1=gr, 
            grid1=get(grName), 
            # vars=c("species", "obs_int"), 
            vars=c(intVar1.2, intVar2.2), 
            x_lab=lab,
          y_lab = yl)
}
```

#### Plot manually - question 1
Now the above ones aren't working (where I tried to make it automated), so try 
entering the variables manually:




```{r eval=FALSE, include=FALSE, warning=FALSE}

# this is for question 1:
# 
# modnum <- 4
modnum <- 10
dat <- impDat
# vars <- c("species", "nest_age")
vars <- c("species", "obs_int")
y_lab="Predicted Probability of \nUnknown Field Fate"
# x_lab="Nest Age in Days (centered)"
x_lab="Final Interval in Days (centered)"
mm <- sym(vars[1])
xx <- sym(vars[2])
grpColor <- c( CONI="#44AA99",LETE="#AA4499")
 
model   <- with(dat,
                glm(as.formula(paste0(resp, modList[[modnum]])),
                family=binomial,
                method=regMet
                ))
# intPred <- 
grid1 <- fullGridObs
intPred <- marginaleffects::predictions(model, newdata=grid1)
# intPred <- marginaleffects::predictions(model, type="link", newdata=grid1)
pl <- ggplot(intPred,
       # aes(x=obs_int, y=estimate, ymin=conf.low, ymax=conf.high, color=species)) +
       # aes(x=as.numeric(obs_int), y=estimate, ymin=conf.low, ymax=conf.high, color=species)) +
       aes(x=obs_int, y=estimate, ymin=conf.low, ymax=conf.high, color=species)) +
       # aes(x=!!xx, y=estimate, color=!!mm)) +
       # aes(x=nest_age, y=estimate, color=species)) +
  # geom_point() +
  labs(x=x_lab, y=y_lab)+
  # ylim(0,1)+ # using ylim by itself modifies the underlying data
  coord_cartesian(ylim=c(0,1))+ 
  scale_color_manual(values=grpColor,
                     labels=c("Common\nNighthawk", "Least Tern"),
                     name="Species") +
  # geom_smooth(method=NULL) +
  geom_line() +
  geom_ribbon(alpha=0.2)+
  theme_classic() +
  theme(axis.text = element_text(size=18),
  axis.title = element_text(size=20), # can't do margins for x and y axis titles at once
  legend.text=element_text(size=16),
  legend.title=element_text(size=18),
  axis.title.y = element_text(margin=margin(r=5)),
  axis.title.x = element_text(margin=margin(t=5))) 
#  pl3 <- intPlot(impDat,                             # (interaction between species & nest_age)
#           # modnum=5)
#           modnum=4,
#           vars = c("species", "obs_int"), # in this case, intVar1 should always be species
#           # grid1=gr,
#           grid1=intGridObs,
#           x_lab="Final interval - centered (days)",
#           y_lab="Predicted probability of\nunknown field fate")
#   # ,
#           # y_lab="Predicted probability of\n unknown field fate")                   
# # }
# pl3

pl
```

#### plot manually - question 2 

```{r eval=FALSE, include=FALSE, warning=FALSE}
# for question 2
# try not using the function at all

# grid1 <- intGridAge
modnum <- 5
dat <- impDat
vars <- c("species", "nest_age")
y_lab="Predicted Probability of \nMisclassification"
x_lab="Nest Age in Days (centered)"
mm <- sym(vars[1])
xx <- sym(vars[2])
grpColor <- c( CONI="#44AA99",LETE="#AA4499")

model   <- with(dat, glm(as.formula(paste0(resp, modList[[modnum]])),
                         family=binomial,
                         method=regMet
                         )
                )

grid1 <- fullGridAge
# this function is supposed to take imputations as input, but I don't think it calculates the
# SE correctly. try creating a list of model fits for each of m datasets, and then pooling

# this was just working and now it throws a missing std.error column error!
# but only for model 4. weird. nevere mind. just had misplaced parentheses
intPred <- marginaleffects::predictions(model,
                                        # variables=c("species", "nest_age"),
                                        # variables=c("species"), # try just including X
                                        # type="response", # need this to use glm.fit method?
                                        newdata=grid1
)
# Error: This function does not support multiple imputation. Call `predictions()` or `avg_predictions()` instead. These functions return easy to plot data frames.
# intPredPlot <- marginaleffects::plot_predictions(model,
#                                                  newdata=grid1)

pl <- ggplot(intPred,
       # aes(x=obs_int, y=estimate, ymin=conf.low, ymax=conf.high, color=species)) +
       # aes(x=as.numeric(obs_int), y=estimate, ymin=conf.low, ymax=conf.high, color=species)) +
       aes(x=nest_age, y=estimate, ymin=conf.low, ymax=conf.high, color=species)) +
       # aes(x=!!xx, y=estimate, color=!!mm)) +
       # aes(x=nest_age, y=estimate, color=species)) +
  # geom_point() +
  labs(x=x_lab, y=y_lab)+
  scale_color_manual(values=grpColor,
                     labels=c("Common\nNighthawk", "Least Tern"),
                     name="Species") +
  # geom_smooth(method=NULL) +
  geom_line() +
  geom_ribbon(alpha=0.2)+
  theme_classic() +
  theme(axis.text = element_text(size=18),
  axis.title = element_text(size=20), # can't do margins for x and y axis titles at once
  legend.text=element_text(size=16),
  legend.title=element_text(size=18),
  axis.title.y = element_text(margin=margin(r=5)),
  axis.title.x = element_text(margin=margin(t=5))) 
# pl1 <- intPlot(impDat,                             # (interaction between species & nest_age)
# # intPlot(impDat,                             # (interaction between species & nest_age)
#           # modnum=5)
#           modnum=5,
#           # plot_type="slope",
#           vars = c("species", "nest_age"), # in this case, intVar1 should always be species
#           # grid1=gr,
#           grid1=intGridAge,
#           x_lab="Nest age - centered (days)",
#           y_lab="Predicted probability of \nmisclassification")
pl

# I got this warning before, but I forget why...
# Warning :[38;5;111mFailed to fit group 1.[39m Caused by error in `smooth.construct.cr.smooth.spec()`: [33m![39m x has insufficient unique values to support 10 knots: reduce k.
# Warning :[38;5;111mFailed to fit group 2.[39m Caused by error in `smooth.construct.cr.smooth.spec()`: [33m![39m x has insufficient unique values to support 10 knots: reduce k.
# and maybe this one too:
# Warning :[38;5;111mNo shared levels found between `names(values)` of the manual scale and the data's [32mcolour[38;5;111m values.[39m
```



```{r eval=FALSE, include=FALSE}
# # modList[[5]]
# # mod5 <- paste0("HF_mis ", modList[[5]])
# # mod5
# impDatsmall2 <- imputeDat(imppDat, m=10, return="complete")
# modFit <- lapply( impDatsmall2, function (x) {
#   glm(HF_mis ~ nest_age * species + fdate + obs_int + cam_fate, 
#       data = x, 
#       family = binomial,
#       method = brglmFit)}
# )
# 
# pred <- lapply(modFit, function(x){
#   # Error: This command will generate many estimates. Set `options(marginaleffects_safe=FALSE)` to circumvent this guardrail.
#   # marginaleffects::predictions(x, newdata=fullGridAge, hypothesis=~pairwise)
#   marginaleffects::predictions(x, newdata=fullGridAge)
# })
# # pred$term <- pred$hypothesis
# # the pool function needs a column named "term", but which column? the example is confusing
# predPool <- mice::pool(pred)
```


```{r eval=FALSE, include=FALSE}
# for question 2
# pl2 <- intPlot(impDat,                             # (interaction between species & nest_age)
#           # modnum=5)
#           modnum=4,
#           vars = c("species", "obs_int"), # in this case, intVar1 should always be species
#           # grid1=gr,
#           grid1=intGridObs,
#           x_lab="Final interval - centered (days)",
#           y_lab="Predicted probability of \nmisclassification")
# pl2
modnum <- 4
dat <- impDat
vars <- c("species", "obs_int")
y_lab="Predicted Probability of \nMisclassification"
x_lab="Final Interval in Days (centered)"
mm <- sym(vars[1])
xx <- sym(vars[2])
grpColor <- c( CONI="#44AA99",LETE="#AA4499")

model   <- with(dat, glm(as.formula(paste0(resp, modList[[modnum]])),
                         family=binomial,
                         method=regMet
                         ))
grid1 <- fullGridObs
# this function is supposed to take imputations as input, but I don't think it calculates the
# SE correctly. try creating a list of model fits for each of m datasets, and then pooling


intPred <- marginaleffects::predictions(model,
                                        newdata=grid1
)
                
pl <- ggplot(intPred,
       # aes(x=obs_int, y=estimate, ymin=conf.low, ymax=conf.high, color=species)) +
       # aes(x=as.numeric(obs_int), y=estimate, ymin=conf.low, ymax=conf.high, color=species)) +
       aes(x=obs_int, y=estimate, ymin=conf.low, ymax=conf.high, color=species)) +
       # aes(x=!!xx, y=estimate, color=!!mm)) +
       # aes(x=nest_age, y=estimate, color=species)) +
  # geom_point() +
  labs(x=x_lab, y=y_lab)+
  scale_color_manual(values=grpColor,
                     labels=c("Common\nNighthawk", "Least Tern"),
                     name="Species") +
  # geom_smooth(method=NULL) +
  geom_line() +
  geom_ribbon(alpha=0.2)+
  theme_classic() +
  theme(axis.text = element_text(size=18),
  axis.title = element_text(size=20), # can't do margins for x and y axis titles at once
  legend.text=element_text(size=16),
  legend.title=element_text(size=18),
  axis.title.y = element_text(margin=margin(r=5)),
  axis.title.x = element_text(margin=margin(t=5))) 
pl
```

